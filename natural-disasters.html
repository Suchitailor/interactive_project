<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="js/d3.v7.js"></script>
    <title>Natural Disasters 1970-2024</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@1.0.2/css/bulma.min.css">
  </head>
  <body>
    <section class="title">
        <h1 class="title">
            Natural Disasters 1970-2021
        </h1>
    </section>
    <section class = "data-load">
        <script>
            // try {
            //     const disasters = d3.csv("data/1970-2021_DISASTERS.csv");
            //     console.log(disasters);
            // } catch (error) {
            //     console.error(error);
            // };

            // try {
            //     const url = "https://ourworldindata.org/grapher/economic-damage-from-natural-disasters.csv?v=1&csvType=filtered&useColumnShortNames=true&tab=table&time=1970..2021"
            //     const damages = d3.csv(url);
            //     console.log(damages);
            // } catch (error) {
            //     console.error(error);
            // };
        </script>
    </section>
    <section>
        <h2 class="subheader">
            Country Breakdown 
        </h2>
        <select id="countryselectButton"></select>
        <div id="countryBreakdown"></div>
        <script>
            fetch('data/cleaned/annual_country_freq.csv') 
                .then(response => response.text()) 
                .then(csvString => {
                    const country_freq = d3.csvParse(csvString, (d) => { 
                        return {
                        year: d.Year, 
                        country: d.Country,
                        disasterType: d.disasterType,
                        frequency: +d.len
                        }}
                    )
                        console.log(country_freq);


                        // Specify the chartâ€™s dimensions.
                        const width= 1300;
                        const height = 600;
                        const marginTop = 20;
                        const marginRight = 20;
                        const marginBottom = 30;
                        const marginLeft = 30;

                        // Create the positional scales.
                        // const x = d3.scaleUtc()
                        // .domain(d3.extent(country_freq, d => d.year))
                        // .range([marginLeft, width - marginRight]);

                        // const y = d3.scaleLinear()
                        // .domain([0, d3.max(country_freq, d => d.frequency)]).nice()
                        // .range([height - marginBottom, marginTop]);
                        
                        // console.log(d3.extent(country_freq, d => d.year)); // Should output [minDate, maxDate]
                        // console.log([0, d3.max(country_freq, d => d.frequency)]); // Should output [0, maxFrequency]

                        
                        // // Create the SVG container.
                        let div1 = d3
                            .select("#countryBreakdown")
                            .append("svg")
                            .attr("width", width)
                            .attr("height", height)
                            .attr("viewBox", [0, 0, width, height])
                            .attr("style", "max-width: 100%; height: auto; overflow: visible; font: 10px sans-serif;");

                        // // Add the horizontal axis.
                        // div1.append("g")
                        //     .attr("transform", `translate(0,${height - marginBottom})`)
                        //     .call(d3.axisBottom(x));

                        // // Add the vertical axis.
                        // div1.append("g")
                        //     .attr("transform", `translate(${marginLeft},0)`)
                        //     .call(d3.axisLeft(y))
                        //     .call(g => g.append("text")
                        //         .attr("x", -marginLeft)
                        //         .attr("y", 10)
                        //         .attr("fill", "currentColor")
                        //         .attr("text-anchor", "start")
                        //         .text("Number of Disasters"));
                        
                        let options = [...new Set(country_freq.map(d => d.country))].sort(); 
                        let disType = [...new Set(country_freq.map(d => d.disasterType))].sort(); 
                        let allYears = [...new Set(country_freq.map(d => d.year))].sort(); 
                        options.unshift("Select Country")

                        d3.select("#countryselectButton")
                            .selectAll('myOptions')
                            .data(options)
                            .enter()
                            .append('option')
                            .text(function (d) {
                                return d; }) // text showed in the menu
                            .attr("value", function (d) { return d; }); // corresponding value returned by the button
                        
                        d3
                            .select("#countryselectButton")
                            .on("change", function(d) {
                                // remove all existing bars & axes
                                d3.selectAll(`#countrybars`).remove()
                                d3.selectAll(`#countryaxis`).remove()

                                // recover the option that has been chosen
                                var selectedCountry = d3.select(this).property("value")
                                console.log(selectedCountry)
                                countrydata = country_freq.filter(d => d.country === selectedCountry)
                                console.log(countrydata)

                            const series = d3.stack()
                                .keys(d3.union(countrydata.map(d => d.disasterType))) // distinct series keys, in input order
                                .value(([, D], key) => D.get(key)?.frequency || 0) // get value for each series key and stack, default 0 
                                (d3.index(countrydata, d => d.year, d => d.disasterType)); // group by stack then series key
                            

                        // Prepare the scales for positional and color encodings.
                            const x = d3.scaleBand()
                                //.domain(countrydata.map(d => d.year))
                                .domain(allYears)
                                .range([marginLeft, width - marginRight])
                                .padding(0.1);
                            
                            console.log(x.domain());
                            const y = d3.scaleLinear()
                                .domain([0, 1.25 * (d3.max(series, d => d3.max(d, d => d[1])))])
                                .rangeRound([height - marginBottom, marginTop]);

                            const color = d3.scaleOrdinal()
                                .domain(series.map(d => d.key))
                                .range(d3.schemeSpectral[disType.length])
                                .unknown("#ccc");

                            // A function to format the value in the tooltip.
                            const formatValue = x => isNaN(x) ? "N/A" : x.toLocaleString("en")


                            // Append the horizontal axis.
                            div1.append("g")
                                .attr("transform", `translate(0,${height - marginBottom})`)
                                .attr("id", 'countryaxis')
                                .call(d3.axisBottom(x).tickSizeOuter(0))
                                .call(g => g.selectAll(".domain").remove());

                            // Append the vertical axis.
                            div1.append("g")
                                .attr("transform", `translate(${marginLeft},0)`)
                                .attr("id", 'countryaxis')
                                .call(d3.axisLeft(y).ticks(null, "s"))
                                .call(g => g.selectAll(".domain").remove());
                            
                             // Append a group for each series, and a rect for each element in the series.
                            div1.append("g")
                                .selectAll()
                                .data(series)
                                .join("g")
                                .attr("fill", d => color(d.key))
                                .selectAll("rect")
                                .data(D => D.map(d => (d.key = D.key, d)))
                                .join("rect")
                                .attr("x", d => x(d.data[0]))
                                .attr("y", d => y(d[1]))
                                .attr("height", d => y(d[0]) - y(d[1]))
                                .attr("width", x.bandwidth())
                                .attr("id", 'countrybars')
                                .append("title")
                                .text(d => `${d.data[0]} ${d.key}\n${formatValue(d.data[1].get(d.key).frequency)}`);

                                })

                                let legend = d3
                                    .select("#countryBreakdown")
                                    .append("svg")
                                    .attr("width", 200)
                                    .attr("height", 200)
                                    .attr("viewBox", "0 -20 200 200")
                                    .attr("transform", "translate(800,-400)")
                                    .attr("id", "legend");

                                    const titlePadding = 14;  // padding between title and entries
                                    const entrySpacing = 16;  // spacing between legend entries
                                    const labelOffset = 2;    // additional horizontal offset of text labels
                                    const baselineOffset = 8; // text baseline offset, depends on height and font size

                                    const title = legend.append('text')
                                    .attr('x', 0)
                                    .attr('y', 0)
                                    .attr('fill', 'white')
                                    .attr('font-family', 'Helvetica Neue, Arial')
                                    .attr('font-weight', 'bold')
                                    .attr('font-size', '10px')
                                    .text('Disaster Type');

                                    const entries = legend
                                    .selectAll('g')
                                    .data(d3.schemeSpectral[disType.length])
                                    .join('g')
                                    .attr('transform', (d, i) => `translate(800, ${titlePadding + i * entrySpacing})`);

                                    const symbols = entries.append('rect')
                                    .attr('width', 10) // <-- offset symbol x-position by radius
                                    .attr('height', 10)
                                    .attr('fill', d => d);

                                    const labels = entries.append('text')
                                    .attr('x', 20 + labelOffset) // <-- place labels to the left of symbols
                                    .attr('y', baselineOffset) // <-- adjust label y-position for proper alignment
                                    // .attr('fill', 'White')
                                    // .attr('font-family', 'Helvetica Neue, Arial')
                                    // .attr('font-size', '11px')
                                    // exclude "All"
                                    .text((d,i) => disType[i]);              



                })




                .catch(error => console.error('Error fetching CSV:', error)); 
            


        </script>
    </section>
    </body>
</html>